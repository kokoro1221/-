/ *！
 * jQuery Migrate  -  v1.4.1  -  2016-05-19
 * Copyright jQuery Foundationおよびその他の寄稿者
 * /
（function（jQuery、window、undefined）{
// http://bugs.jquery.com/ticket/13335を参照
// "strictを使用する";


jQuery.migrateVersion = "1.4.1";


var warnedAbout = {};

//既に与えられている警告のリスト。一般公開のみ
jQuery.migrateWarnings = [];

//コンソール出力を行わないようにするにはtrueに設定します。まだ維持されているmigrateWarnings
// jQuery.migrateMute = false;

//コンソールにメッセージを表示するので、devsは私たちがアクティブであることを知っています
if（window.console && window.console.log）{
	window.console.log（ "JQMIGRATE：Migrateがインストールされています" +
		（jQuery.migrateMute？ ""： "ロギング有効"）+
		"、version" + jQuery.migrateVersion）;
}

//警告とともに表示されるトレースを無効にするには、falseに設定します
if（jQuery.migrateTrace === undefined）{
	jQuery.migrateTrace = true;
}

//既に与えられている警告を無視する。パブリック
jQuery.migrateReset = function（）{
	warnedAbout = {};
	jQuery.migrateWarnings.length = 0;
};

関数migrateWarn（msg）{
	var console = window.console;
	if（！warnedAbout [msg]）{
		warnedAbout [msg] =真;
		jQuery.migrateWarnings.push（msg）;
		if（console && console.warn &&！jQuery.migrateMute）{
			console.warn（ "JQMIGRATE：" + msg）;
			if（jQuery.migrateTrace && console.trace）{
				console.trace（）;
			}
		}
	}
}

関数migrateWarnProp（obj、prop、value、msg）{
	if（Object.defineProperty）{
		// ES5ブラウザ（非oldIE）では、コードがpropを取得しようとすると警告します。
		//他のプラグインが必要な場合にプロパティを上書きすることを許可する
		試して{
			Object.defineProperty（obj、prop、{
				設定可能：true、
				enumerable：true、
				get：function（）{
					migrateWarn（msg）;
					戻り値。
				}、
				set：function（newValue）{
					migrateWarn（msg）;
					value = newValue;
				}
			}）;
			戻る;
		} catch（err）{
			// IE8はObject.definePropertyに関するドープであり、そこに警告することはできません
		}
	}

	//非ES5（または壊れた）ブラウザ。プロパティを設定するだけです
	jQuery._definePropertyBroken = true;
	obj [prop] = value;
}

if（document.compatMode === "BackCompat"）{
	// jQueryはQuirksモードをサポートまたはテストしていません
	migrateWarn（ "jQueryはQuirksモードと互換性がありません"）;
}


var attrFn = jQuery（ "<input />"、{size：1}）.attr（ "size"）&& jQuery.attrFn、
	oldAttr = jQuery.attr、
	valueAttrGet = jQuery.attrHooks.value && jQuery.attrHooks.value.get ||
		function（）{nullを返します。}、
	valueAttrSet = jQuery.attrHooks.value && jQuery.attrHooks.value.set ||
		function（）{未定義を返します。}、
	rnoType = / ^（？：input | button）$ / i、
	rnoAttrNodeType = / ^ [238] $ /、
	rboolean = / ^（？：自動フォーカス|自動再生|非同期|チェック|コントロール|遅延|無効|隠れた|ループ|複数|オープン|読み込み専用|必須|スコープ付き|選択）$ / i、
	ruseDefault = / ^（？：チェックされている|選択されている）$ / i;

// jQuery.attrFn
migrateWarnProp（jQuery、 "attrFn"、attrFn || {}、 "jQuery.attrFnは非推奨です"）;

jQuery.attr = function（elem、name、value、pass）{
	var lowerName = name.toLowerCase（）、
		nType = elem && elem.nodeType;

	if（pass）{
		//パスは内部的に使用されるため、新しいjQueryについてのみ警告します
		//仮引数に渡し引数がないバージョン
		if（oldAttr.length <4）{
			migrateWarn（ "jQuery.fn.attr（props、pass）は非推奨です"）;
		}
		if（elem &&！rnoAttrNodeType.test（nType）&&
			（attrFnのattrFnの名前：jQuery.isFunction（jQuery.fn [name]）））{
			return jQuery（elem）[name]（value）; return jQuery（elem）;名前を返します。
		}
	}

	//ユーザーがIE 6/7/8で壊れているので、 `type`を設定しようとすると警告します。チェックして
	//切断された要素に対しては$（ "<button>"、{type： "button"}）で警告しません。
	if（name === "type" && value！== undefined && rnoType.test（elem.nodeName）&& elem.parentNode）{
		migrateWarn（ "IE 6/7/8の入力またはボタンの 'タイプ'を変更できません）。
	}

	// booleanプロパティ/属性の同期を復元するboolHook
	if（！jQuery.attrHooks [lowerName] && rboolean.test（lowerName））{
		jQuery.attrHooks [lowerName] = {
			get：function（elem、name）{
				//ブール値の属性を対応するプロパティと整列させる
				//いくつかのブール値がサポートされていない属性の存在にフォールバックする
				var attrNode、
					プロパティ= jQuery.prop（elem、name）;
				return property === true || typeofプロパティ！== "boolean" &&
					（attrNode = elem.getAttributeNode（name））&& attrNode.nodeValue！== false？

					name.toLowerCase（）：
					未定義;
			}、
			set：function（elem、value、name）{
				var propName;
				if（value === false）{
					// falseに設定されている場合はboolean属性を削除
					jQuery.removeAttr（elem、name）;
				} else {
					//この値はboolean型で、falseでないことがわかっているので、valueはtrueです。
					//ブール値の属性を同じ名前に設定し、DOMプロパティを設定する
					propName = jQuery.propFix [name] || 名;
					if（elemのpropName）{
						// IDLが要素に既に存在する場合にのみIDLを設定する
						elem [propName] = true;
					}

					elem.setAttribute（name、name.toLowerCase（））;
				}
				名前を返す。
			}
		};

		// 1.9以降のプロパティとは異なるままにできる属性に対してのみ警告する
		if（ruseDefault.test（lowerName））{
			migrateWarn（ "jQuery.fn.attr（ '" + lowerName + "'）は属性の代わりにプロパティを使用するかもしれません"）;
		}
	}

	return oldAttr.call（jQuery、elem、name、value）;
};

// attrHooks：value
jQuery.attrHooks.value = {
	get：function（elem、name）{
		var nodeName =（elem.nodeName || ""）.toLowerCase（）;
		if（nodeName === "button"）{
			return valueAttrGet.apply（this、arguments）;
		}
		if（nodeName！== "input" && nodeName！== "option"）{
			migrateWarn（ "jQuery.fn.attr（ 'value'）はプロパティを取得しなくなりました。
		}
		elemの名前を返しますか？
			elem.value：
			ヌル;
	}、
	set：function（elem、value）{
		var nodeName =（elem.nodeName || ""）.toLowerCase（）;
		if（nodeName === "button"）{
			return valueAttrSet.apply（this、arguments）;
		}
		if（nodeName！== "input" && nodeName！== "option"）{
			migrateWarn（ "jQuery.fn.attr（ 'value'、val）プロパティが設定されなくなりました。
		}
		// setAttributeも使用されるように返さない
		elem.value = value;
	}
};


varマッチ、ブラウザ、
	oldInit = jQuery.fn.init、
	oldFind = jQuery.find、
	oldParseJSON = jQuery.parseJSON、
	rspaceAngle = / ^ \ s * </、
	rattrHashTest = / \ [（\ s * [ -  \ w] + \ s *）（[〜| ^ $ *]？=）\ s *（[ -  \ w＃] *？＃[ -  \ w＃] * ）\ s * \] /、
	ラットのHashGlob = / \（\ s * [ -  \ w] + \ s *）（[〜| ^ $ *]？=）\ s *（[ -  \ w＃] *？＃[ -  \ w＃] * ）\ s * \] / g、
	//注：文字列がトリミングされた後、XSSチェックが行われます。
	rquickExpr = / ^（[^ <] *）（<[\ w \ W] +>）（[^>] *）$ /;

// $（html） "htmlのように見える"ルールの変更
jQuery.fn.init = function（セレクタ、コンテキスト、ルートjQuery）{
	var match、ret;

	if（セレクタ&& typeofセレクタ=== "string"）{
		if（！jQuery.isPlainObject（context）&&
				（match = rquickExpr.exec（jQuery.trim（selector）））&& match [0]）{

			//これは "古い"規則によるHTML文字列です。それはまだですか？
			if（！rspaceAngle.test（selector））{
				migrateWarn（ "$（html）HTML文字列は '<'文字 'で始まる必要があります）;
			}
			if（match [3]）{
				migrateWarn（ "$（html）HTMLタグは最後のタグの後に無視されます"）;
			}

			//ハッシュで始まるHTML形式の文字列を一貫して拒否する（gh-9521）
			//これは、そうでなければ動作するjQuery 1.6.xコードを破る可能性があることに注意してください。
			if（match [0] .charAt（0）=== "＃"）{
				migrateWarn（ "HTML文字列は '＃'文字で始めることはできません）;
				jQuery.error（ "JQMIGRATE：無効なセレクタ文字列（XSS）"）;
			}

			//緩いルールを使って処理する。1.8より前にプレーさせる
			//これはjQueryコンテキストですか？parseHTMLはDOM要素を想定しています（＃178）
			if（context && context.context && context.context.nodeType）{
				context = context.context;
			}

			if（jQuery.parseHTML）{
				return oldInit.call（これは、
						jQuery.parseHTML（match [2]、context && context.ownerDocument ||
							文脈|| ドキュメント、真）、コンテキスト、rootjQuery）;
			}
		}
	}

	ret = oldInit.apply（これ、引数）;

	//セレクタとコンテキストのプロパティを入力して.live（）が動作するようにします
	if（selector && selector.selector！== undefined）{
		// jQueryオブジェクト、そのプロパティをコピーする
		ret.selector = selector.selector;
		ret.context = selector.context;

	} else {
		ret.selector = typeofセレクタ=== "文字列"？セレクター： "";
		if（セレクタ）{
			ret.context = selector.nodeType？セレクタ：コンテキスト|| 資料;
		}
	}

	return ret;
};
jQuery.fn.init.prototype = jQuery.fn;

jQuery.find = function（セレクタ）{
	var args = Array.prototype.slice.call（arguments）;

	//サポート：PhantomJS 1.x
	//一部の文字列でのみ// g RegExpで使用すると、一致する文字列は一致しません
	if（typeof selector === "string" && rattrHashTest.test（selector））{

		//標準でない、文書化されていないunquoted-hashがjQuery 1.12.0で削除されました
		//まず、qSが有効なセレクタだと思っているかどうかを確認します。
		試して{
			document.querySelector（セレクタ）;
		} catch（err1）{

			// qSAに対して有効であるとは見ていませんでした。
			セレクタ= selector.replace（rattrHashGlob、function（_、attr、op、value）{
				return "[" + attr + op + "\" "+ value +" \ "]";
			}）;

			// regexp *が無効なセレクタを作成した可能性がある場合は、それを更新しないでください
			//セレクタがjQuery拡張機能を使用すると、誤ったアラームが発生する可能性があることに注意してください
			試して{
				document.querySelector（セレクタ）;
				migrateWarn（ "属性セレクタは '＃'を引用符で囲む必要があります：" + args [0]）;
				args [0] = selector;
			} catch（err2）{
				migrateWarn（ "属性セレクタ '＃'は修正されていませんでした：" + args [0]）;
			}
		}
	}

	return oldFind.apply（this、args）;
};

//オリジナルのjQuery.findメソッドに添付されたプロパティをコピーする（例：.attr、.isXML）
var findProp;
for（oldFindのfindProp）{
	if（Object.prototype.hasOwnProperty.call（oldFind、findProp））{
		jQuery.find [findProp] = oldFind [findProp];
	}
}

// $ .parseJSON（falsy_value）がnullを返すようにする
jQuery.parseJSON = function（json）{
	if（！json）{
		migrateWarn（ "jQuery.parseJSONには有効なJSON文字列が必要です"）;
		nullを返す。
	}
	return oldParseJSON.apply（これは引数）;
};

jQuery.uaMatch = function（ua）{
	ua = ua.toLowerCase（）;

	var match = /（chrome）[\ /]（[\ w。] +）/。exec（ua）||
		/（Webkit）[\ /]（[\ w。] +）/。exec（ua）||
		/（opera）（？：。* version |）[\ /]（[\ w。] +）/。exec（ua）||
		/（msie）（[\ w。] +）/。exec（ua）||
		ua.indexOf（ "compatible"）<0 && /(mozilla)(?:.*？rv：（[\ w。] +）|）/。exec（ua）||
		[];

	戻り値{
		ブラウザ：一致[1] || ""、
		バージョン：一致[2] || "0"
	};
};

//既存のjQuery.browserを違反しないようにする
if（！jQuery.browser）{
	一致= jQuery.uaMatch（navigator.userAgent）;
	ブラウザ= {};

	if（matched.browser）{
		ブラウザ[matched.browser] = true;
		browser.version = matched.version;
	}

	// ChromeはWebkitですが、WebkitもSafariです。
	if（browser.chrome）{
		browser.webkit = true;
	} else if（browser.webkit）{
		browser.safari = true;
	}

	jQuery.browser = browser;
}

//コードがjQuery.browserを取得しようとすると警告する
migrateWarnProp（jQuery、 "browser"、jQuery.browser、 "jQuery.browserは非推奨です"）;

// 1.3で廃止されたjQuery.boxModel、1.7で廃止されたjQuery.support.boxModel
jQuery.boxModel = jQuery.support.boxModel =（document.compatMode === "CSS1Compat"）;
migrateWarnProp（jQuery、 "boxModel"、jQuery.boxModel、 "jQuery.boxModelは廃止されました"）;
migrateWarnProp（jQuery.support、 "boxModel"、jQuery.support.boxModel、 "jQuery.support.boxModelは非推奨"です。

jQuery.sub = function（）{
	関数jQuerySub（セレクタ、コンテキスト）{
		新しいjQuerySub.fn.init（セレクタ、コンテキスト）を返します。
	}
	jQuery.extend（true、jQuerySub、this）;
	jQuerySub.superclass = this;
	jQuerySub.fn = jQuerySub.prototype = this（）;
	jQuerySub.fn.constructor = jQuerySub;
	jQuerySub.sub = this.sub;
	jQuerySub.fn.init =関数init（セレクタ、コンテキスト）{
		var instance = jQuery.fn.init.call（this、selector、context、rootjQuerySub）;
		instance instanceof jQuerySubを返しますか？
			インスタンス：
			jQuerySub（インスタンス）;
	};
	jQuerySub.fn.init.prototype = jQuerySub.fn;
	var rootjQuerySub = jQuerySub（ドキュメント）;
	migrateWarn（ "jQuery.sub（）は推奨されていません"）;
	jQuerySubを返す。
};

//一致した要素セットに含まれる要素の数
jQuery.fn.size = function（）{
	migrateWarn（ "jQuery.fn.size（）は推奨されていません.lengthプロパティを使用してください）";
	return this.length;
};


var internalSwapCall = false;

//このバージョンのjQueryに.swap（）がある場合は、内部使用時にfalse-alarmをしないでください
if（jQuery.swap）{
	jQuery.each（["height"、 "width"、 "reliableMarginRight"]、関数（_、name）{
		var oldHook = jQuery.cssHooks [name] && jQuery.cssHooks [name] .get;

		if（oldHook）{
			jQuery.cssHooks [name] .get = function（）{
				var ret;

				internalSwapCall = true;
				ret = oldHook.apply（これは引数）;
				internalSwapCall = false;
				return ret;
			};
		}
	}）;
}

jQuery.swap = function（elem、options、callback、args）{
	var ret、name、
		古い= {};

	if（！internalSwapCall）{
		migrateWarn（ "jQuery.swap（）は文書化されておらず、非推奨です"）;
	}

	//古い値を記憶し、新しい値を挿入する
	for（オプションの名前）{
		古い[名前] = elem.style [名前];
		elem.style [name] =オプション[name];
	}

	ret = callback.apply（elem、args || []）;

	//古い値を元に戻す
	for（オプションの名前）{
		elem.style [name] =古い[name];
	}

	return ret;
};


// $ .ajaxがcore.jsで定義された新しいparseJSONを取得するようにする
jQuery.ajaxSetup（{
	コンバーター：{
		"text json"：jQuery.parseJSON
	}
}）;


var oldFnData = jQuery.fn.data;

jQuery.fn.data = function（name）{
	var ret、evt、
		elem = this [0];

	//このビヘイビアを持つ1.7を処理します。
	if（elem && name === "events" && arguments.length === 1）{
		ret = jQuery.data（elem、name）;
		evt = jQuery._data（elem、name）;
		if（（ret === undefined || ret === evt）&& evt！== undefined）{
			migrateWarn（ "jQuery.fn.data（ 'events'）の使用は推奨されません。
			return evt;
		}
	}
	return oldFnData.apply（this、arguments）;
};


var rscriptType = / \ /（java | ecma）スクリプト/ i;

//古いバージョンではjQuery.cleanが内部的に使用されているため、見つからない場合にのみshimします
if（！jQuery.clean）{
	jQuery.clean = function（elems、コンテキスト、フラグメント、スクリプト）{
		// 1.8ロジックごとにコンテキストを設定する
		コンテキスト=コンテキスト|| 資料;
		context =！context.nodeType && context [0] || コンテキスト;
		context = context.ownerDocument || コンテキスト;

		migrateWarn（ "jQuery.clean（）は推奨されていません"）;

		var i、elem、handleScript、jsTags、
			ret = [];

		jQuery.merge（ret、jQuery.buildFragment（elems、context）.childNodes）;

		// jQuery 1.8から直接持ち上げられた複雑なロジック
		if（フラグメント）{
			//各スクリプト要素の特別な処理
			handleScript = function（elem）{
				//実行可能と見なすかどうかを確認する
				if（！elem.type || rscriptType.test（elem.type））{
					//スクリプトをデタッチし、スクリプト配列（指定されている場合）またはそのフラグメントに格納します
					//それが処理されたことを示す真理値を返します
					スクリプトを返しますか？
						scripts.push（elem.parentNode？elem.parentNode.removeChild（elem）：elem）：
						fragment.appendChild（elem）;
				}
			};

			for（i = 0;（elem = ret [i]）！= null; i ++）{
				//実行可能なスクリプトを処理した後に完了したかどうかを確認する
				if（！（jQuery.nodeName（elem、 "script"）&& handleScript（elem）））{
					//フラグメントに追加して埋め込みスクリプトを処理する
					fragment.appendChild（elem）;
					if（typeof elem.getElementsByTagName！== "undefined"）{
						// handleScriptはDOMを変更するので、jQuery.mergeを使用してスナップショットの繰り返しを保証します
						jsTags = jQuery.grep（jQuery.merge（[]、elem.getElementsByTagName（ "script"））、handleScript）;

						//元の祖先の後でスクリプトをretに分割し、それらの先にインデックスを進める
						ret.splice.apply（ret、[i + 1、0] .concat（jsTags））;
						i + = jsTags.length;
					}
				}
			}
		}

		return ret;
	};
}

var eventAdd = jQuery.event.add、
	eventRemove = jQuery.event.remove、
	eventTrigger = jQuery.event.trigger、
	oldToggle = jQuery.fn.toggle、
	oldLive = jQuery.fn.live、
	oldDie = jQuery.fn.die、
	oldLoad = jQuery.fn.load、
	ajaxEvents = "ajaxStart | ajaxStop | ajaxSend | ajaxComplete | ajaxError | ajaxSuccess"、
	rajaxEvent = new RegExp（ "\\ b（?:" + ajaxEvents + "）\\ b"）、
	rhoverHack = /(?:^|\s)hover(\.\S+|)\b/、
	hoverHack = function（events）{
		if（typeof（events）！== "string" || jQuery.event.special.hover）{
			イベントを返す。
		}
		if（rhoverHack.test（events））{
			migrateWarn（ "'ホバー'擬似イベントは廃止されました。 'mouseenter mouseleave'"を使用してください）;
		}
		戻りイベント&& events.replace（rhoverHack、 "mouseenter $ 1 mouseleave $ 1"）;
	};

//イベントプロップを1.9で削除し、必要に応じてそれらを戻します。それらに警告する実際的な方法はありません
if（jQuery.event.props && jQuery.event.props [0]！== "attrChange"）{
	jQuery.event.props.unshift（ "attrChange"、 "attrName"、 "relatedNode"、 "srcElement"）;
}

//ドキュメント化されていないjQuery.event.handleはjQuery 1.7で「非推奨」でした。
if（jQuery.event.dispatch）{
	migrateWarnProp（jQuery.event、 "handle"、jQuery.event.dispatch、 "jQuery.event.handleは文書化されておらず、廃止予定です"）;
}

// 'hover'擬似イベントとajaxイベントの警告をサポート
jQuery.event.add = function（elem、types、handler、data、selector）{
	if（elem！== document && rajaxEvent.test（types））{
		migrateWarn（ "AJAXイベントはドキュメントに添付する必要があります：" + types）;
	}
	eventAdd.call（this、elem、hoverHack（types || ""）、ハンドラ、データ、セレクタ）;
};
jQuery.event.remove = function（elem、types、handler、selector、mappedTypes）{
	イベントハンドラ、セレクタ、mappedTypes）;
};

jQuery.each（["load"、 "unload"、 "error"]、関数（_、name）{

	jQuery.fn [name] = function（）{
		var args = Array.prototype.slice.call（arguments、0）;

		//これがajax load（）の場合、最初のargは文字列URLでなければなりません。
		//技術的には、これはイベントの "Anything" argでもかまいません。
		//これはなぜこのダム署名が非難されたのかを示しています！
		// Ajaxモジュールを除外したjQueryカスタムビルドは、ここで正当に死ぬ。
		if（name === "load" && typeof args [0] === "string"）{
			return oldLoad.apply（this、args）;
		}

		migrateWarn（ "jQuery.fn。" + name + "（）は非推奨です"）;

		args.splice（0、0、name）;
		if（arguments.length）{
			これを返す.bind.apply（this、args）;
		}

		//ここで.triggerHandlerを使用します：
		//  - ロードとアンロードのイベントはバブルする必要はなく、ウィンドウまたはイメージにのみ適用されます
		//  - エラーイベントは、プレ1.7にもかかわらず、ウィンドウにバブルしないでください。
		// http://bugs.jquery.com/ticket/11820を参照
		this.triggerHandler.apply（this、args）;
		これを返す。
	};

}）;

jQuery.fn.toggle = function（fn、fn2）{

	//アニメーションやCSSの切り替えをしないでください
	if（！jQuery.isFunction（fn）||！jQuery.isFunction（fn2））{
		return oldToggle.apply（これは引数）;
	}
	migrateWarn（ "jQuery.fn.toggle（handler、handler ...）は非推奨です"）;

	//クロージャでアクセスするための引数への参照を保存する
	var args = arguments、
		guid = fn.guid || jQuery.guid ++、
		i = 0、
		toggler = function（イベント）{
			//実行する関数を特定する
			var lastToggle =（jQuery._data（this、 "lastToggle" + fn.guid）|| 0）％i;
			jQuery._data（これは "lastToggle" + fn.guid、lastToggle + 1）;

			//クリックが停止していることを確認します
			event.preventDefault（）;

			//関数を実行する
			return args [lastToggle] .apply（this、arguments）|| 偽;
		};

	//すべての関数をリンクするので、いずれの関数もこのクリックハンドラをアンバインドできます
	toggler.guid = guid;
	while（i <args.length）{
		args [i ++] .guid = guid;
	}

	return this.click（toggler）;
};

jQuery.fn.live = function（型、データ、fn）{
	migrateWarn（ "jQuery.fn.live（）は推奨されていません"）;
	if（oldLive）{
		return oldLive.apply（これは引数）;
	}
	jQuery（this.context）.on（タイプ、this.selector、data、fn）;
	これを返す。
};

jQuery.fn.die = function（types、fn）{
	migrateWarn（ "jQuery.fn.die（）は非推奨です"）;
	if（oldDie）{
		return oldDie.apply（これは引数）;
	}
	jQuery（this.context）.off（型、this.selector || "**"、fn）;
	これを返す。
};

//グローバルイベントをドキュメントトリガイベントに変換
jQuery.event.trigger = function（イベント、データ、elem、onlyHandlers）{
	if（！elem &&！rajaxEvent.test（event））{
		migrateWarn（ "グローバルなイベントは文書化されておらず、廃止予定です"）;
	}
	return eventTrigger.call（this、event、data、elem ||ドキュメント、onlyHandlers）;
};
jQuery.each（ajaxEvents.split（ "|"）、
	関数（_、name）{
		jQuery.event.special [name] = {
			セットアップ：function（）{
				var elem = this;

				//ドキュメントにシミングは必要ありません。oldIEのために===でなければならない
				if（elem！== document）{
					jQuery.event.add（document、name + "。" + jQuery.guid、function（）{
						jQuery.event.trigger（name、Array.prototype.slice.call（arguments、1）、elem、true）;
					}）;
					jQuery._data（this、name、jQuery.guid ++）;
				}
				偽を返します。
			}、
			ティアダウン：function（）{
				if（this！== document）{
					jQuery.event.remove（ドキュメント、名前+ "。" + jQuery._data（this、name））;
				}
				偽を返します。
			}
		};
	}
）;

jQuery.event.special.ready = {
	セットアップ：function（）{
		if（this ===ドキュメント）{
			migrateWarn（ "'ready'イベントは非推奨です）;
		}
	}
};

var oldSelf = jQuery.fn.andSelf || jQuery.fn.addBack、
	oldFnFind = jQuery.fn.find;

jQuery.fn.andSelf = function（）{
	migrateWarn（ "jQuery.fn.andBack（）"に置き換えられた "jQuery.fn.andSelf（）"）;
	return oldSelf.apply（これは引数）;
};

jQuery.fn.find = function（selector）{
	var ret = oldFnFind.apply（これ、引数）;
	ret.context = this.context;
	ret.selector = this.selector？this.selector + "" +セレクタ：セレクタ。
	return ret;
};


// jQuery 1.6はコールバックをサポートしていませんでした。
if（jQuery.Callbacks）{

	var oldDeferred = jQuery.Deferred、
		タプル= [
			//アクション、add listener、callbacks、.thenハンドラ、最終状態
			["resolve"、 "done"、jQuery.Callbacks（ "once once memory"）、
				jQuery.Callbacks（ "once memory"）、 "resolved"]、
			["reject"、 "fail"、jQuery.Callbacks（ "once once memory"）、
				jQuery.Callbacks（ "once memory"）、 "rejected"]、
			[通知]、[進捗状況]、jQuery.Callbacks（ "メモリ"）、
				jQuery.Callbacks（ "memory"）]
		];

	jQuery.Deferred = function（func）{
		var deferred = oldDeferred（）、
			promise = deferred.promise（）;

		deferred.pipe = promise.pipe = function（/ * fnDone、fnFail、fnProgress * /）{
			var fns = arguments;

			migrateWarn（ "deferred.pipe（）は推奨されていません"）;

			return jQuery.Deferred（function（newDefer）{
				jQuery.each（tuples、function（i、tuple）{
					var fn = jQuery.isFunction（fns [i]）&& fns [i];
					// deferred.done（function（）{newDeferまたはnewDefer.resolveにバインド}）
					// deferred.fail（function（）{newDeferまたはnewDefer.rejectにバインド}）
					// deferred.progress（function（）{newDeferまたはnewDefer.notifyにバインド}）
					deferred [tuple [1]]（function（）{
						var returned = fn && fn.apply（これ、引数）;
						if（返された&& jQuery.isFunction（返された。プロミス））{
							返された.promise（）
								.done（newDefer.resolve）
								.fail（newDefer.reject）
								.progress（newDefer.notify）;
						} else {
							newDefer [tuple [0] + "With"]]（
								これは約束ですか？newDefer.promise（）：これは、
								fn？[返された]：引数
							）;
						}
					}）;
				}）;
				fns = null;
			}）。約束する（）;

		};

		deferred.isResolved = function（）{
			migrateWarn（ "deferred.isResolvedは非推奨"）;
			return deferred.state（）=== "解決済み";
		};

		deferred.isRejected = function（）{
			migrateWarn（ "deferred.isRejectedは非推奨"）。
			return deferred.state（）=== "rejected";
		};

		if（func）{
			func.call（遅延、遅延）;
		}

		リターン延期。
	};

}

}）（jQuery、ウィンドウ）;